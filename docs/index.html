<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
    <link rel="stylesheet" href="./css/main.css">
    <title>How to make gRPC microservices on windows machine</title>
</head>

<body>
    <div class="general_div">
        <div class="nav">
            <h1>Navigation</h1>
        </div>
        <div class="nav_text">
            <ol>
                <li><a href="#warning_ref">A word of warning</a></li>
                <li><a href="#description_ref">Description</a></li>
                <li><a href="#goal_ref">Main goal of this article</a></li>
                <li><a href="#grpc_ref">gRPC for better sanity</a></li>
                <li><a href="#proto_ref">Creating Your proto file</a></li>
                <li><a href="#config_proto_ref">Downloading and configuring proto compiler</a></li>
                <li><a href="#Csharp_ref">Creating C# .NET Framework microservice</a></li>
                <li><a href="#cplus_ref">Creating C++ microservice</a></li>
            </ol>
        </div>
    </div>
    <div class="warning general_div">
        <div class="header">
            <a name="warning_ref"/>
            <h1>A word of warning</h1>
        </div>
        <p>While reading this article keep in mind that I am only 19 years old and still going to school, I am not a junior dev/programmer but I have worked for a few companies and had some practice. </p>
    </div>
    <div class="prev general_div" id="description_ref">
        <div class="header">
            <h1>Description</h1>
        </div>
        <div class="general_text">
            Hi there, <b>You!</b> <br/>
            So You want to make a <b>gRPC microservice</b> on a <b>Windows</b> platform but You are getting lost in the <a href="https://grpc.io/">tutorial on the main site?</a> No worries, I will show You the easiest way possible to start this jorney! <p>Actually I am working with gRPC microservices for about three and a half week and I've found out that setting all these things up on a windows machine is a pain. I was searching for a good article explaining how to set things up and stuff but it just was not working for me. </p>
            <p>
                At the end I was just trying all these <b>bazel</b> techniques from <a href="https://github.com/grpc/">gRPC main Git repo</a> and was pulling hair off my head really quickly. After I finally figured it all out (they acually recommended all this stuff tho, I just wasn't very patient and did not read whole README from the beggining to the end) I thought of making a tutorial for people who have the same problem as I once had.
               
            </p></div>      
    </div>
    <div class="entry general_div" id="goal_ref">
        <div class="header">
            <h1>Main goal of this aricle</h1>
        </div>
        <div class="general_text">
        We are going to create a bunch of <b>gRPC microservices</b> from scratch in <b>C#, C++, Go</b> and <b>RUST.</b> <br/> All code that I post here will be availabe together with all other files and solution on my <a href="https://github.com/TheFunnySunny/gRPC-microservices-windows"><b>Github repository.</b></a>
        </div>
        <div class="ending_text">
            <b>Enough talking, lets get started!</b>
        </div>
    </div>
    <div class="grpc general_div">
        <div class="header">
            <a name="grpc_ref"/>
            <h1>gRPC for better sanity</h1>
        </div>
        <div class="general_text">
        So from my point of view <b>gRPC (general Remote Procedural Calls)</b> as a technique is better than any other at the level of design. If you have read the main page of gRPC you probably know that it is easy to distribute everything once you have defined Your PROTO file and stuff like that (more on that in a while).<br/><br/>For me as for someone who had to test performane of gRPC it is as fast as other protocols (well, HTTP2 actually) and much more beautiful and easier to make. But hey, You've chosen it already so I do not have to talk about it, but I will leave a <a href="https://grpc.io/docs/guides/">link</a> for You if you want to jump onto definitions.
        </div>
    </div>
    <div class="protobu general_divf" id="proto_ref">
        <div class="header">
            <h1>Creating Your proto file</h1>
        </div>
        <div class="general_text">
        Okay, lets actually get started. A <i><b>proto</b></i> file is something where all the magic of gRPC happens. Let me actually show You a simple <i><b>proto</b></i> file that we will be working with along this article. It is actually nearly the same as in the examples from gRPC tutorials but we want to keep it simple for now.
        </div>
        <div>
        <pre class="code_wrapper"><code>
        syntax = "proto3";

        package Talk;
        
        service Greeter {
        rpc SayHello (HelloRequest) returns (HelloReply) {}
        }
        
        // The request message containing the user's name.
        message HelloRequest {
        string name = 1;
        string date = 2;
        }
        
        // The response message containing the greetings
        message HelloReply {
        string message = 1;
        }
        </code></pre>
        <div class="code_footer">
            <b>Talk.proto</b>
        </div>
        </div>
        <div class="general_text">
        Writing proto files is actually pretty simple, I will post my <a href="">simple c++ console communicator</a> created with gRPC so You can take a look at different definition of a protofile.<br/><br/>
        So by looking at the code we can actually see what is going to happend but there are several things to point out so let me do that real quick:<br/>
        <ol>
            <li><b>syntax = "proto3"</b> specifies which version of proto we will be using (there is version 3 right know, have You ever heard of previous 2 tho?),</li>
            <li><b>package Talk</b> acts like a<i>namespace</i>in C# or C++,</li>
            <li><b>service Greeter</b> creates a <b>class</b> with name <b>Greeter</b>. You can pick any name You want and You can have multiple<i>services</i> (<b>classes</b>) in one proto file, </li>
            <li>This line: <b>rpc SayHello (HelloRequest) returns (HelloReply) {}</b> is actually a casual method definition (or a function, You choose which term You like). Lets split it into a few parts: 
                <ul>
                    <li>We start with <b>rpc</b> and I have not dig deep into that but I guess we can conclude that is just sayin' -<i>'hey, this is an rpc function!',</i></li>
                    <li>then we specify what <b>name</b >we want our function to have. Again - it is Your job to choose it, like in a normal program,
                    </li>
                    <li>after that cones what do we expect as an <b>argument</b> (for us it will be<b>HelloRequest</b>) to the function. Simpler - what will client send to the server. Remember to put that in the brackets!</li>
                    <li><b>returns</b> means what You think it means,</li>
                    <li><b>HelloReply</b> is what will <b>server</b> send back to the <b>client</b>. We again put it in the brackets,</li>
                    <li>curly braces at the end acutally may mean something but I have yet not discover any use of writing anything into them. We will specify what will out rpc function do in the code so we just put them for the sake of proto compiler.</li>
                    </ul></li>
            <li><b>message</b> specifies what we will exchange between our services. We can call them small classes that define our type that we will send and receive:
                <ul>
                <li>we have to specify the name of our type -<b>HelloRequest</b> and <b>HelloReply</b> in our case,</li>
                <li>between <b>curly braces</b> you specify what variables will Your type contain. I have added 1 more variable so You do't think We can't give it more than one,</li>
                <li>You can find what types are supported by looking up proto3 documentation. We use <b>string</b> in both cases so we will just exchange some text,</li>
                <li><b>=1; or =2;</b> just specify what place do they take in our type. going from 1 to whatever You like is common and easy to do, I have not yet found any place in the code where I would do otherwise than counting from 1 up.
                </li>
                </ul></li>
            <li>and last but not least: we create messages appropiate to what we have defined in our <b>SayHello</b> function. If we had more functionsusing different messages we would have to create them here.</li>
        </ol>
        Well, maybe it was not very short explanation but We now know about every aspect of our proto so You will never have to stare at something and think<i>'why is it there? Do I write it like that?'.</i> <br/><br/>
            What we have to do now is to create files that mach our programming language. We will do that individually for each language, but <b>first you will need protoc compiler (ignore this step if You only want to create for C#. <a href = "#Csharp_ref">Navigate to that place</a>).</b> </div>
    </div>
    <div class="protobuf_config general_div" id="config_proto_ref">
        <div class="header">
            <h1>Downloading and configuring proto compiler</h1>
        </div>
        <div class="general_text">
        To save ourselves from a lot of headache we are going to use <b>vcpkg</b> that can be <a href="https://github.com/Microsoft/vcpkg">downloaded here</a>. Vcpkg is a brilliant tool that lets you download a lot of things like protobuf or grpc and any other libraries and programs.<br/>I have downloaded it with git but you can do it by just downloading the zip file and extracting it somewhere, it will be the same. Remember where you put your vcpkg. For me it is: <i>C:\vcpkg</i>. To build vcpkg.exe (trust me we need that) you can fallow the tutorial on main site provided above or go into <b><i>scripts</i></b> folder inside vcpkg (for me it is <i>C:\vcpkg\scripts</i>) and run bootstrap.ps1 from powershell. I forgot to mention that everytime I do something in console it is going to be <b>powershell</b>.<br/> Okay, so we have vcpkg.exe ready to use, I mean, nearly ready. We need to use 'vcpkg' command from PS and for now You can't do that. To make it visible for PS and cmd fallow these steps:
            <ol>
                <li>Open 'start' or just click windows button on your keyboard and start typing <b>'envi'</b> and 'Edit the system Environment Variables' will pop-up. Click on it,
                </li>
                <li>'System Properties' windows should open. At the right bottom you can see <b>Environment Variables...</b>, click on that button,
                </li>
                <li>
                    another window pops up. On the second list - <b>System variables</b> find <b>PATH</b> and double click on it or once and 'Edit...',
                </li>
                <li>now you can see a windows called 'Edit environment variable'. Click on <b>New</b> on the left and paste the location of your vcpkg.exe file in here (for me it is <i>C:\vcpkg</i>). Do not add any more text at the end! So it looks like that at the end: <br/><img src="./images/vcpkg.JPG"/>
                </li>
                <li>then just click <b>Ok</b> everywhere and we are gucci,</li>
                <li>now just open new instance of PS and type 'vcpkg' and a cool list of options should be presented.</li>
            </ol>
            We have downloaded vcpkg, now it is time for our <b>proto compiler.</b> Protoc is a part of Protobuf project maintained by Google itself. To download what we need fallow these few steps: 
            <ol>
                <li>Open PS and type: <i>vcpkg install protobuf</i>,</li>
                <li>download will start, just wait till it all finishes (it will take time, be patient. If you think it has frozen.. no, that just take some time, especcialy <b>building windows-rel</b>. You may need to turn off your antivirus for that).<b>Very important thing to note!!! Sometimes PS can get stucked while downloading this stuff. You can click on the PS and press any key on your keyboard so it receives some interrupt, it may speed things up. Anytime you think it takes too long try to do that trick.</b></li><li> then again open <b>Edit the System Environment Variables</b> like in the previous step,</li>
                <li>again navigate to <b>Path</b> in <b>System Variables</b> and Edit it,</li>
                <li>click on <b>New</b> and add path to newly downloaded <b>protoc.exe</b>. <br/>Note: All things you download with vcpkg are put into <b>packages</b> folder inside vcpkg folder, so for me it is <i>C:\vcpkg\packages</i>.<br/> Full path to <b>protoc.exe</b> in my case is <i>C:\vcpkg\packages<b>\protobuf_x86-windows\tools\protobuf</b></i> and this is the path we will copy into <b>PATH</b> in <b>System Variables</b>, at the end I have that: <br/><img src="./images/protoc_path.JPG"/></li>
                <li>now, <b>after reopening PS</b> and typing <b>protoc</b> you can see a list of commands for our use.</li>
            </ol>
            <b>We are set up and ready to create our projects!</b>
        </div>
    </div>
    <div class="C# general_div">
        <div class="header" id="Csharp_ref">
            <h1>Creating C# .NET Framework microservice</h1>
        </div>
        <div class="general_text">
            First on our list is C#. we do not need protoc for that as I mentioned before. This is the easiest case and I guess most people will want to build in .NET or .NET Core anyway so lets get started!<br/>
            Okay, standard stuff: I am using <b>Visual Studio 2017 Community</b> so everything I am doing is going to be dictated by it for now.<br/> Jumping in - One VS2017, File -> New Project -> Visual C# -> Class Library (.NET Framework). Give it a name and we are ready to go! <br/> <b>Note that .NET Framework has to be >= 4.5 for gRPC to work.</b> Also we are going to create a console app to not get distracted but it will be the same for a regular WPF app. Also also we start with .DLL because.. there is no because, you can start with a server or client class and steps will be the nearly the same.<br/><img style="width: 70vw" src="./images/Creating_Csharp_proj.JPG"/><br/>
            <b>Also note that name can be anything you want! It is only an accident that my proto package name and dll name are the same.</b>
            <b>Second note: Switch your mode from Debug to Release so all libraries will be linked with our solution to make it compatibile from the get-go.</b>
            <ol><li>From <b>Talk</b> delete <b>class1.cs</b> or whatever was created in your project. After that operation your solution exploler should look like that: <br/><img src="./images/solution_exp_Csharp_first.JPG"/></li>
                <li>Right click on the <b>Talk</b> project (in green) in <b>Solution exploler</b> and click on <b>Manage NuGet Packages</b>,</li>
                <li>now we have to install a few things: <b>Google.Protobuf</b>, <b>Grpc</b>, <b>Grpc.Core</b> and <b>Grpc.Tools</b>It should look like that after everything is installed (+ System.Interactive.Async because it comes with project when creating it):<br/><img style="width: 75vw"  src="./images/proto_nuget_packages.JPG"/></li>
                <li>after doing that we have to add <b>Talk.proto</b> to the <b>Talk</b> project. Yuo can copy-paste our existing proto file to solution directory or just add new file and copy-paste code from proto. W/e you do, it should look like that:<br/><img src="./images/solution_exp_Csharp_sec.JPG"/></li>
                <li>close VS2017 and reopen it. If you don't do that you won't be able to do next step,</li>
                <li>after you are back to the solution, open <b>Solution Exploler</b> and right-click on the <b>Talk.proto</b> file and <b>Properties</b>. Under <b>Advanced</b> options select <b>'Build Action' -> ProtoBuf.</b> Should look like that: <br/><img src="./images/properties_Csharp_talk.JPG"/></li>
            </ol>
            Cool! We've got the most importat thing set up and ready to go. Now we have to create our server and client projects inside our main solution. To do that: <ol><li>Right click on <b>Solution 'Talk' (1 project)</b> and <b>Add -> New project</b>. Choose <b>Visual C# -> Console App (.NET Framework)</b> and pick an appropriate name, i go with <b>MyServer</b> and <b>MyClient</b>. Should look like that: <br/><img style="width: 70vw" src="./images/Csharp_adding_server.JPG"/></li></ol>
            After you've created botch client and server your Solution Exploler should look like that: <br/><img src="images/solution_exp_Csharp_third.JPG"/><br/>Nice! Okay, now there are two important steps before we get to the programming part: <ol><li>Add NuGet packages to both <b>client</b> and <b>server</b> projects. You do it like before but do not download <b>Grpc.Tools</b> for these two,</li>
            <li>at the top of the screen you can see Program.cs for each client and server. If not, just open them. Click on one of them and navigate to <b>Project->Add reference...</b> at the top of the screen. In projects check box right next to Talk, like that: <br/><img style="width: 70vw" src="./images/Csharp_references.JPG"/><br/>Then just click <b>OK</b>, switch to the other Project.cs (just click on it in the bar at the top so you can see the code of it on the screen) and do the same.</li></ol> 
            So we have all configuration done and we are ready to write some code. Let's start from our server code: 
        <div>
            <pre class="code_wrapper"><code>using Grpc.Core;
using Talk;
using System.Threading.Tasks;
using System;
namespace MyServer
{
    class TalkImpl : Greeter.GreeterBase
    {
        // Server side handler of the SayHello RPC
        public override Task &ltHelloReply&gt SayHello
        (HelloRequest request, ServerCallContext context)
        {
        Console.WriteLine("Hello" + request.Name);
        return Task.FromResult(
        new HelloReply { Message = "Hello" + request.Name }
        );
        }
    }
    class Program
    {
        const int Port = 50051;
        public static void Main(string[] args)
        {
            string address = "0.0.0.0";
            Grpc.Core.Server server = new Grpc.Core.Server
            {
            Services = { Greeter.BindService(new TalkImpl()) },
            Ports = { 
            new ServerPort(address, Port, ServerCredentials.Insecure)
            }};
            server.Start();
            Console.WriteLine("Greeter server listening on port " + Port);
            Console.WriteLine("Press any key to stop the server...");
            Console.ReadKey();            
            server.ShutdownAsync().Wait();
        }
    }
}                </code></pre>
            <div class="code_footer">                
            <b>Program.cs from MyServer project</b>
            </div>
        </div>
          I would like to talk about each and every aspect of that code but It will not be very educational so lets just point at the most crucial points of the code: <ul> <li><b>class TalkImpl : Greeter.GreeterBase</b> creates a class that will refer to our Greeter, this is how we start defining thigs from out <b>proto</b> file,</li>
            <li><b>public override Task &ltHelloReply&gt SayHello
        (HelloRequest request, ServerCallContext context)</b> again refers to the function we have defined in <b>proto</b> file. Simple, ain' it?</li><li>we can do what we want in the function body but at the end we have to return what we have specified in the <b>Talk.proto</b>, in this case it is <b>HelloReply</b>. Look at the whole class and method once again and you understand everything.</li><li>In Main we create a server instance and bind as a service,</li><li>we also specify server port and address on which our server will be listening (IP: 0.0.0.0 means it will listen on all IPs availabe on your PC and port is your choosing, 50051 in our case) and credencials (in our case: insecure),</li><li>at the end we just start the server and if someone clicks a key everything stops.</li></ul>  
            And that is our server! After we send <b>HelloRequest</b> to it we will recieve a <b>HelloReply</b> with a new message. The only thing left now is to create a client, lets do it! 
            <div>
            <pre class="code_wrapper"><code>using System;
using Grpc.Core;
using Talk;
namespace MyClient
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Enter your name: ");
            String user = Console.ReadLine();
            Channel channel = new Channel(
            "127.0.0.1:50051",
            ChannelCredentials.Insecure);
            var client = new Greeter.GreeterClient(channel);
            HelloReply reply = client.SayHello(
            new HelloRequest { Name = user }
            );
            Console.WriteLine(reply.Message);
            Console.WriteLine("Press any key to exit...");
            Console.ReadKey();
        }
    }
}                </code></pre>
            <div class="code_footer">                
            <b>Program.cs from MyClient project</b>
            </div>
        </div>
            This one is actually easier than the server. We create a <b>channel</b> which specifies IP and port to which we are going to connect. After making a channel instance we create a <b>client</b> that connects to that channel. At the end we just call <b>SayHello</b> function with the parameter <b>HelloRequest</b> with a <b>name</b> (as in the <b>proto</b> file).<br/>
            Only thing that's left it to <b>build</b> the project, run Server and then client and boom!<br/><img src="./images/csharp_done.JPG"/><br/>Hope you were able to compile and run everything without any problems. All code is available <a href = "https://github.com/TheFunnySunny/gRPC-microservices-windows/tree/master/C%23">here.</a> It may have different structure than your solution because I've made a mistake when creating <b>MyClient</b> and put it in the <b>Talk</b> folder but that is nothing bad (at least for the compiler). In the future I'll do better!
    </div>        
    </div>
    <div class="cplus_div" id="cplus_ref">
        <div class="header">
            <h1>Creating C++ microservice</h1>
        </div>
        <div class="general_text">
        </div>
    </div>
</body>
</html>