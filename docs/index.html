<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
    <link rel="stylesheet" href="./css/main.css">
    <title>How to make gRPC microservices on windows machine</title>
</head>

<body>
    <div class="general_div">
        <div class="nav">
            <h1>Navigation</h1>
        </div>
        <div class="nav_text">
            <ol>
                <li><a href="#warning_ref">A word of warning</a></li>
                <li><a href="#description_ref">Description</a></li>
                <li><a href="#goal_ref">Main goal of this article</a></li>
                <li><a href="#grpc_ref">gRPC for better sanity</a></li>
                <li><a href="#proto_ref">Creating Your proto file</a></li>
                <li><a href="#config_proto_ref">Downloading and configuring proto compiler</a></li>
                <li><a href="#Csharp_ref">Creating C# .NET Framework microservice</a></li>
                <li><a href="#cplus_ref">Creating C++ microservice</a></li>
                <li><a href="#go_ref">Creating Go microservice</a></li>
                <li><a href = "rust_ref">Creating RUST microservice</a></li>
            </ol>
        </div>
    </div>
    <div class="warning general_div" id="warning_ref">
        <div class="header">
            <h1>A word of warning</h1>
        </div>
        <p>While reading this article keep in mind that I am only 19 years old and still going to school, I am not a junior dev/programmer but I have worked for a few companies and had some practice. </p>
    </div>
    <div class="prev general_div" id="description_ref">
        <div class="header">
            <h1>Description</h1>
        </div>
        <div class="general_text">
            Hi there, <b>You!</b> <br/>
            So You want to make a <b>gRPC microservice</b> on a <b>Windows</b> platform but You are getting lost in the <a href="https://grpc.io/">tutorial on the main site?</a> No worries, I will show You the easiest way possible to start this jorney! <p>Actually I am working with gRPC microservices for about three and a half week and I've found out that setting all these things up on a windows machine is a pain. I was searching for a good article explaining how to set things up and stuff but it just was not working for me. </p>
            <p>
                At the end I was just trying all these <b>bazel</b> techniques from <a href="https://github.com/grpc/">gRPC main Git repo</a> and was pulling hair off my head really quickly. After I finally figured it all out (they acually recommended all this stuff tho, I just wasn't very patient and did not read whole README from the beggining to the end) I thought of making a tutorial for people who have the same problem as I once had.
               
            </p></div>      
    </div>
    <div class="entry general_div" id="goal_ref">
        <div class="header">
            <h1>Main goal of this aricle</h1>
        </div>
        <div class="general_text">
        We are going to create a bunch of <b>gRPC microservices</b> from scratch in <b>C#, C++, Go</b> and <b>RUST.</b> <br/> All code that I post here will be availabe together with all other files and solution on my <a href="https://github.com/TheFunnySunny/gRPC-microservices-windows"><b>Github repository.</b></a>
        </div>
        <div class="ending_text">
            <b>Enough talking, lets get started!</b>
        </div>
    </div>
    <div class="grpc general_div">
        <div class="header">
            <a name="grpc_ref"/>
            <h1>gRPC for better sanity</h1>
        </div>
        <div class="general_text">
        So from my point of view <b>gRPC (general Remote Procedural Calls)</b> as a technique is better than any other at the level of design. If you have read the main page of gRPC you probably know that it is easy to distribute everything once you have defined Your PROTO file and stuff like that (more on that in a while). What is more important is that you can send gRPC requests between services written in completely different languages! So for example client can be written in C++ and server might be in RUST and they can talk to each other like tkey know themselves from years!<br/><br/>For me as for someone who had to test performane of gRPC it is as fast as other protocols (well, HTTP2 actually) and much more beautiful and easier to make. But hey, You've chosen it already so I do not have to talk about it, but I will leave a <a href="https://grpc.io/docs/guides/">link</a> for You if you want to jump onto definitions.
        </div>
    </div>
    <div class="protobu general_divf" id="proto_ref">
        <div class="header">
            <h1>Creating Your proto file</h1>
        </div>
        <div class="general_text">
        Okay, lets actually get started. A <i><b>proto</b></i> file is something where all the magic of gRPC happens. Let me actually show You a simple <i><b>proto</b></i> file that we will be working with along this article. It is actually nearly the same as in the examples from gRPC tutorials but we want to keep it simple for now.
        </div>
        <div>
        <pre class="code_wrapper"><code>
        syntax = "proto3";

        package Talk;
        
        service Greeter {
        rpc SayHello (HelloRequest) returns (HelloReply) {}
        }
        
        // The request message containing the user's name.
        message HelloRequest {
        string name = 1;
        string date = 2;
        }
        
        // The response message containing the greetings
        message HelloReply {
        string message = 1;
        }
        </code></pre>
        <div class="code_footer">
            <b>Talk.proto</b>
        </div>
        </div>
        <div class="general_text">
        Writing proto files is actually pretty simple, I will post my <a href="">simple c++ console communicator</a> created with gRPC so You can take a look at different definition of a protofile.<br/><br/>
        So by looking at the code we can actually see what is going to happend but there are several things to point out so let me do that real quick:<br/>
        <ol>
            <li><b>syntax = "proto3"</b> specifies which version of proto we will be using (there is version 3 right know, have You ever heard of previous 2 tho?),</li>
            <li><b>package Talk</b> acts like a<i>namespace</i>in C# or C++,</li>
            <li><b>service Greeter</b> creates a <b>class</b> with name <b>Greeter</b>. You can pick any name You want and You can have multiple<i>services</i> (<b>classes</b>) in one proto file, </li>
            <li>This line: <b>rpc SayHello (HelloRequest) returns (HelloReply) {}</b> is actually a casual method definition (or a function, You choose which term You like). Lets split it into a few parts: 
                <ul>
                    <li>We start with <b>rpc</b> and I have not dig deep into that but I guess we can conclude that is just sayin' -<i>'hey, this is an rpc function!',</i></li>
                    <li>then we specify what <b>name</b >we want our function to have. Again - it is Your job to choose it, like in a normal program,
                    </li>
                    <li>after that cones what do we expect as an <b>argument</b> (for us it will be<b>HelloRequest</b>) to the function. Simpler - what will client send to the server. Remember to put that in the brackets!</li>
                    <li><b>returns</b> means what You think it means,</li>
                    <li><b>HelloReply</b> is what will <b>server</b> send back to the <b>client</b>. We again put it in the brackets,</li>
                    <li>curly braces at the end acutally may mean something but I have yet not discover any use of writing anything into them. We will specify what will out rpc function do in the code so we just put them for the sake of proto compiler.</li>
                    </ul></li>
            <li><b>message</b> specifies what we will exchange between our services. We can call them small classes that define our type that we will send and receive:
                <ul>
                <li>we have to specify the name of our type -<b>HelloRequest</b> and <b>HelloReply</b> in our case,</li>
                <li>between <b>curly braces</b> you specify what variables will Your type contain. I have added 1 more variable so You do't think We can't give it more than one,</li>
                <li>You can find what types are supported by looking up proto3 documentation. We use <b>string</b> in both cases so we will just exchange some text,</li>
                <li><b>=1; or =2;</b> just specify what place do they take in our type. going from 1 to whatever You like is common and easy to do, I have not yet found any place in the code where I would do otherwise than counting from 1 up.
                </li>
                </ul></li>
            <li>and last but not least: we create messages appropiate to what we have defined in our <b>SayHello</b> function. If we had more functionsusing different messages we would have to create them here.</li>
        </ol>
        Well, maybe it was not very short explanation but We now know about every aspect of our proto so You will never have to stare at something and think<i>'why is it there? Do I write it like that?'.</i> <br/><br/>
            What we have to do now is to create files that mach our programming language. We will do that individually for each language, but <b>first you will need protoc compiler (ignore this step if You only want to create for C#. <a href = "#Csharp_ref">Navigate to that place</a>).</b> </div>
    </div>
    <div class="protobuf_config general_div" id="config_proto_ref">
        <div class="header">
            <h1>Downloading and configuring proto compiler</h1>
        </div>
        <div class="general_text">
        To save ourselves from a lot of headache we are going to use <b>vcpkg</b> that can be <a href="https://github.com/Microsoft/vcpkg">downloaded here</a>. Vcpkg is a brilliant tool that lets you download a lot of things like protobuf or grpc and any other libraries and programs.<br/>I have downloaded it with git but you can do it by just downloading the zip file and extracting it somewhere, it will be the same. Remember where you put your vcpkg. For me it is: <i>C:\vcpkg</i>. To build vcpkg.exe (trust me we need that) you can fallow the tutorial on main site provided above or go into <b><i>scripts</i></b> folder inside vcpkg (for me it is <i>C:\vcpkg\scripts</i>) and run bootstrap.ps1 from powershell.<br/> Okay, so we have vcpkg.exe ready to use, I mean, nearly ready. We need to use 'vcpkg' command from PS and for now You can't do that. To make it visible for PS and cmd fallow these steps:
            <ol id="howto_PATH_var">
                <li>Open 'start' or just click windows button on your keyboard and start typing <b>'envi'</b> and 'Edit the system Environment Variables' will pop-up. Click on it,
                </li>
                <li>'System Properties' windows should open. At the right bottom you can see <b>Environment Variables...</b>, click on that button,
                </li>
                <li>
                    another window pops up. On the second list - <b>System variables</b> find <b>PATH</b> and double click on it or once and 'Edit...',
                </li>
                <li>now you can see a windows called 'Edit environment variable'. Click on <b>New</b> on the left and paste the location of your vcpkg.exe file in here (for me it is <i>C:\vcpkg</i>). Do not add any more text at the end! So it looks like that at the end: <br/><img src="./images/vcpkg.JPG"/>
                </li>
                <li>then just click <b>Ok</b> everywhere and we are gucci,</li>
                <li>now just open new instance of PS and type 'vcpkg' and a cool list of options should be presented.</li>
            </ol>
            We have downloaded vcpkg, now it is time for our <b>proto compiler.</b> 
            Here I have to confess that I do not acutally know IF you need to download CMake or no but you can figure it out. Fallow along and if you get any errors about CMake not existing you will have to install it too. Protoc is a part of Protobuf project maintained by Google itself. To download what we need fallow these few steps: 
            <ol>
                <li>Open PS and type: <i>vcpkg install protobuf</i>,</li>
                <li>download will start, just wait till it all finishes (it will take time, be patient. If you think it has frozen.. no, that just take some time, especcialy <b>building windows-rel</b>. You may need to turn off your antivirus for that).<b>Very important thing to note!!! Sometimes PS can get stucked while downloading this stuff. You can click on the PS and press any key on your keyboard so it receives some interrupt, it may speed things up. Anytime you think it takes too long try to do that trick.</b></li><li> then again open <b>Edit the System Environment Variables</b> like in the previous step,</li>
                <li>again navigate to <b>Path</b> in <b>System Variables</b> and Edit it,</li>
                <li>click on <b>New</b> and add path to newly downloaded <b>protoc.exe</b>. <br/>Note: All things you download with vcpkg are put into <b>packages</b> folder inside vcpkg folder, so for me it is <i>C:\vcpkg\packages</i>.<br/> Full path to <b>protoc.exe</b> in my case is <i>C:\vcpkg\packages<b>\protobuf_x86-windows\tools\protobuf</b></i> and this is the path we will copy into <b>PATH</b> in <b>System Variables</b>, at the end I have that: <br/><img src="./images/protoc_path.JPG"/></li>
                <li>now, <b>after reopening PS</b> and typing <b>protoc</b> you can see a list of commands for our use.</li>
            </ol>
            <b>We are set up and ready to create our projects!</b>
        </div>
    </div>
    <div class="C# general_div">
        <div class="header" id="Csharp_ref">
            <h1>Creating C# .NET Framework microservice</h1>
        </div>
        <div class="general_text">
            First on our list is C#. we do not need protoc for that as I mentioned before. This is the easiest case and I guess most people will want to build in .NET or .NET Core anyway so lets get started!<br/>
            Okay, standard stuff: I am using <b>Visual Studio 2017 Community</b> so everything I am doing is going to be dictated by it for now.<br/> Jumping in - One VS2017, File -> New Project -> Visual C# -> Class Library (.NET Framework). Give it a name and we are ready to go! <br/> <b>Note that .NET Framework has to be >= 4.5 for gRPC to work.</b> Also we are going to create a console app to not get distracted but it will be the same for a regular WPF app. Also also we start with .DLL because.. there is no because, you can start with a server or client class and steps will be the nearly the same.<br/><img src="./images/Creating_Csharp_proj.JPG"/><br/>
            <b>Also note that name can be anything you want! It is only an accident that my proto package name and dll name are the same.</b>
            <b>Second note: Switch your mode from Debug to Release so all libraries will be linked with our solution to make it compatibile from the get-go.</b>
            <ol><li>From <b>Talk</b> delete <b>class1.cs</b> or whatever was created in your project. After that operation your solution exploler should look like that: <br/><img src="./images/solution_exp_Csharp_first.JPG"/></li>
                <li>Right click on the <b>Talk</b> project (in green) in <b>Solution exploler</b> and click on <b>Manage NuGet Packages</b>,</li>
                <li>now we have to install a few things: <b>Google.Protobuf</b>, <b>Grpc</b>, <b>Grpc.Core</b> and <b>Grpc.Tools</b>It should look like that after everything is installed (+ System.Interactive.Async because it comes with project when creating it):<br/><img style="width: 75vw"  src="./images/proto_nuget_packages.JPG"/></li>
                <li>after doing that we have to add <b>Talk.proto</b> to the <b>Talk</b> project. Yuo can copy-paste our existing proto file to solution directory or just add new file and copy-paste code from proto. W/e you do, it should look like that:<br/><img src="./images/solution_exp_Csharp_sec.JPG"/></li>
                <li>close VS2017 and reopen it. If you don't do that you won't be able to do next step,</li>
                <li>after you are back to the solution, open <b>Solution Exploler</b> and right-click on the <b>Talk.proto</b> file and <b>Properties</b>. Under <b>Advanced</b> options select <b>'Build Action' -> ProtoBuf.</b> Should look like that: <br/><img src="./images/properties_Csharp_talk.JPG"/></li>
            </ol>
            Cool! We've got the most importat thing set up and ready to go. Now we have to create our server and client projects inside our main solution. To do that: <ol><li>Right click on <b>Solution 'Talk' (1 project)</b> and <b>Add -> New project</b>. Choose <b>Visual C# -> Console App (.NET Framework)</b> and pick an appropriate name, i go with <b>MyServer</b> and <b>MyClient</b>. Should look like that: <br/><img src="./images/Csharp_adding_server.JPG"/></li></ol>
            After you've created botch client and server your Solution Exploler should look like that: <br/><img src="images/solution_exp_Csharp_third.JPG"/><br/>Nice! Okay, now there are two important steps before we get to the programming part: <ol><li>Add NuGet packages to both <b>client</b> and <b>server</b> projects. You do it like before but do not download <b>Grpc.Tools</b> for these two,</li>
            <li>at the top of the screen you can see Program.cs for each client and server. If not, just open them. Click on one of them and navigate to <b>Project->Add reference...</b> at the top of the screen. In projects check box right next to Talk, like that: <br/><img src="./images/Csharp_references.JPG"/><br/>Then just click <b>OK</b>, switch to the other Project.cs (just click on it in the bar at the top so you can see the code of it on the screen) and do the same.</li></ol> 
            So we have all configuration done and we are ready to write some code. Let's start from our server code: 
        <div>
            <pre class="code_wrapper"><code>using Grpc.Core;
using Talk;
using System.Threading.Tasks;
using System;
namespace MyServer
{
    class TalkImpl : Greeter.GreeterBase
    {
        // Server side handler of the SayHello RPC
        public override Task &lt;HelloReply&gt; SayHello
        (HelloRequest request, ServerCallContext context)
        {
        Console.WriteLine("Hello" + request.Name);
        return Task.FromResult(
        new HelloReply { Message = "Hello" + request.Name }
        );
        }
    }
    class Program
    {
        const int Port = 50051;
        public static void Main(string[] args)
        {
            string address = "0.0.0.0";
            Grpc.Core.Server server = new Grpc.Core.Server
            {
            Services = { Greeter.BindService(new TalkImpl()) },
            Ports = { 
            new ServerPort(address, Port, ServerCredentials.Insecure)
            }};
            server.Start();
            Console.WriteLine("Greeter server listening on port " + Port);
            Console.WriteLine("Press any key to stop the server...");
            Console.ReadKey();            
            server.ShutdownAsync().Wait();
        }
    }
}                </code></pre>
            <div class="code_footer">                
            <b>Program.cs from MyServer project</b>
            </div>
        </div>
          I would like to talk about each and every aspect of that code but It will not be very educational so lets just point at the most crucial points of the code: <ul> <li><b>class TalkImpl : Greeter.GreeterBase</b> creates a class that will refer to our Greeter, this is how we start defining thigs from out <b>proto</b> file,</li>
            <li><b>public override Task &lt;HelloReply&gt; SayHello
        (HelloRequest request, ServerCallContext context)</b> again refers to the function we have defined in <b>proto</b> file. Simple, ain' it?</li><li>we can do what we want in the function body but at the end we have to return what we have specified in the <b>Talk.proto</b>, in this case it is <b>HelloReply</b>. Look at the whole class and method once again and you understand everything.</li><li>In Main we create a server instance and bind as a service,</li><li>we also specify server port and address on which our server will be listening (IP: 0.0.0.0 means it will listen on all IPs availabe on your PC and port is your choosing, 50051 in our case) and credencials (in our case: insecure),</li><li>at the end we just start the server and if someone clicks a key everything stops.</li></ul>  
            And that is our server! After we send <b>HelloRequest</b> to it we will recieve a <b>HelloReply</b> with a new message. The only thing left now is to create a client, lets do it! 
            <div>
            <pre class="code_wrapper"><code>using System;
using Grpc.Core;
using Talk;
namespace MyClient
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Enter your name: ");
            String user = Console.ReadLine();
            Channel channel = new Channel(
            "127.0.0.1:50051",
            ChannelCredentials.Insecure);
            var client = new Greeter.GreeterClient(channel);
            HelloReply reply = client.SayHello(
            new HelloRequest { Name = user }
            );
            Console.WriteLine(reply.Message);
            Console.WriteLine("Press any key to exit...");
            Console.ReadKey();
        }
    }
}                </code></pre>
            <div class="code_footer">                
            <b>Program.cs from MyClient project</b>
            </div>
        </div>
            This one is actually easier than the server. We create a <b>channel</b> which specifies IP and port to which we are going to connect. After making a channel instance we create a <b>client</b> that connects to that channel. At the end we just call <b>SayHello</b> function with the parameter <b>HelloRequest</b> with a <b>name</b> (as in the <b>proto</b> file).<br/>
            Only thing that's left it to <b>build</b> the project, run Server and then client and boom!<br/><img src="./images/csharp_done.JPG"/><br/>Hope you were able to compile and run everything without any problems. All code is available <a href = "https://github.com/TheFunnySunny/gRPC-microservices-windows/tree/master/C%23">here.</a> It may have different structure than your solution because I've made a mistake when creating <b>MyClient</b> and put it in the <b>Talk</b> folder but that is nothing bad (at least for the compiler). In the future I'll do better!
    </div>        
    </div>
    <div class="cplus_div" id="cplus_ref">
        <div class="header">
            <h1>Creating C++ microservice</h1>
        </div>
        <div class="general_text">
            To make your first C++ microservice you will may <b>VS2017</b> or at least this is what I'll be using here but if you know CMake you can reproduce all these steps that way. So, let us begin: <ol><li>Open VS2017 and <b>create new Project -> Visual C++ -> Empty Project</b>. We will start from creating a <b>Server</b> so a name corresponding to that will be fitting. I will call my server <b>TalkingServer</b>,</li>
            <li>after our solution is created <b>right click on 'Solution TalkingServer (1 project)' -> Add -> New Project -> Visual C++ -> Empty Project</b> and choose a name. It will be a Client side so I have chosen <b>TalkingClient</b> for a name. I will also place it inside a common folder for my solution, namely <b>D:\SOurceTree_Repo\gRPC-microservices-windows\C++</b>. End result looks like that: <br/><img src="./images/cplus_solutionex_first.JPG"/> <img src="./images/c_plus_exploler_files.JPG"/></li></ol>
            Then switch from <b>Debug</b> to <b>Release</b> just to be safe.<br/>
            Before we get to writing code we have to generate <b>proto files.</b> To do so we will have to use <b>protoc</b> that we have configured earlier. If you haven't do that already please go back to <b>Downloading and Configuring proto compiler.</b><br/>To create gRPC stubs for C++ fallow these steps: <ol><li>Navigate to a directory where you have set up your client and server projects, for me it is <b>D:\SOurceTree_Repo\gRPC-microservices-windows\C++</b> and create a new folder in there called <b>proto</b> so everything looks liek that at the end: <br/><img src="./images/cpp_slution_folders.JPG"/></li><li>copy and paste <b>Talk.proto</b> into the <b>proto</b> folder created in our c++ directory, so for my case it is <b>D:\SOurceTree_Repo\gRPC-microservices-windows\C++\proto</b></li><li>open PS in the directory where your <i>proto</i> file is located and type fallowing commands (in bold text), one by one in that order: <ol>
            <li><b>vcpkg install grpc</b> - this will install all the stuff needed for the compilation. Takes a lot of time on slower machines.<br/><b>A VERY BIG IMPORTANT SIDE NOTE (READ IT):</b> If you get an error while doing that and get something about <b>openssl</b> first thing to do is to open <b>visual studio installer</b> and update your VS. This worked for me and may work for You too.</li>
            <li><b>vcpkg install zlib</b> - this may not install anything because grpc <b>should</b> come with zlib but just in case you can try to do that one too</li>
            <li>if you are wondering where are all these downloaded things stored they are in the 'C:\vcpkg\installed\x86-windows\tools' for me and something similiar for you</li>
            </ol></li>
            <li>navigate your PS to the <b>proto</b> folder in your c++ solution (for me it is 'D:\SOurceTree_Repo\gRPC-microservices-windows\C++\proto'</li>
            <li>run (in PS): <b>protoc --plugin=protoc-gen-grpc=C:\vcpkg\installed\x86-windows\tools\grpc\grpc_cpp_plugin.exe  --grpc_out=. Talk.proto</b><br/>Let me just point to an important thing: As you can see I have specified some path in <b>--plugin</b> option. This is needed here because we haven't added all grpc.exe files to PATH. The point here is that you have to provide a path to <b>grpc_cpp_plugin.exe</b> as I did. Look at my path provided and you can get to that folder and that file too.</li>
            <li>run (in PS): <b>protoc Talk.proto --cpp_out=.</b></li>
            <li>after this two instructions You should see four additional files in your proto directory, that's cool! Picture: <br/><img src="./images/generated_cpp_stubs.JPG"/></li>
            </ol>
            So <b>now</b> we are prepared to jump into actually setting up both client and server and coding them both. Lets add our generated files to client and server respectively:
            <ol>
                <li>in your solution in VS unroll TalkingClient and TalkingServer projects. You can see 4 folders in each of them, right?<br/><img src="./images/folders_screen_cpp.JPG"/></li>
                <li>in both projects do these steps:
                <ul>       
                    
                <li>right click on the project in Solution Exploler and go to <b>Properties</b><ul>
                    <li>right click on Header Files -> Add -> Existing Item... -> navigate to a folder where you have generated your c++ files from Talk.proto and choose files with <b>.h</b> extension. For me it is "Talk.pb.h" and "Talk.grpc.pb.h". Click <b>Add</b></li>
                <li>right click on Source Files -> Add -> Existing Item... -> navigate to a folder with your c++ generated files and choose all with <b>.cc</b> extension. For me it is "Talk.grpc.pb.cc" and "Talk.pb.cc". Click <b>Add</b></li>
                <li>after that both Client and Server solution exploler should look like that:<br/><img src="./images/sol_exp_view_cpp.JPG"/></li>
                    <li>go to <b>Configuration Properties -> VC++ directories</b> and edit <b>Include Directories</b>. Now you have to add path of <b>include</b> folder from <b>vcpkg</b>. For me the path is <b>'C:\vcpkg\installed\x86-windows\include'</b> and path to where you have compiled your <b>proto</b> files, for me it is <b>'D:\SOurceTree_Repo\gRPC-microservices-windows\C++\proto'</b> Click OK</li>
                    <li>while still in <b>VC++ directories</b> edit <b>Library Directories</b> and add path for <b>3</b> lib folders. I will provide you my path and you can figure out where to find them in your <b>vcpkg folder</b> <ul>
                        <li>C:\vcpkg\packages\zlib_x86-windows\lib</li>
                        <li>C:\vcpkg\packages\protobuf_x86-windows\lib</li>
                        <li>C:\vcpkg\packages\grpc_x86-windows\lib</li>
                        </ul>Click on <b>Apply</b> but do not close the window</li>
                    <li>now go to <b>Linker -> Input</b> and add the fallowing items into <b>Additional Dependencies</b>: <ul>
                        <li>gpr.lib</li>
                        <li>grpc.lib</li>
                        <li>grpc_unsecure.lib</li>
                        <li>grpc++_unsecure.lib</li>
                        <li>grpc++_cronet.lib</li>
                        <li>grpc++_error_details.lib</li>
                        <li>grpc++_reflection.lib</li>
                        <li>libprotobuf.lib</li>
                        <li>libprotoc.lib</li>
                        <li>zlib.lib</li>
                        <li>ws2_32.lib</li>
                        </ul></li>
                    <li>Click <b>Apply</b> and <b>OK</b></li>
                    </ul>
                    </li>
                    </ul></li>                
            </ol>
            Cool, everything's ready! Let's start from coding our <b>server</b> first (everything in this part will refer to <b>TalkingServer</b> project, we will do Client side later): 
            <ul>
                <li>in Solution Exploler add new <b>.cpp</b> file that will serve as our main file. I have created <b>Server.cpp</b> file. Open it in VS.</li>
            </ul>
            Code for our simple server looks like that: 
            <div>
            <pre class="code_wrapper"><code>#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;grpcpp/grpcpp.h&gt;
#include &lt;Talk.grpc.pb.h&gt;

using grpc::Status;
using grpc::Channel;
using grpc::Server;
using grpc::Service;
using grpc::ServerContext;
using grpc::ServerBuilder;
using Talk::HelloReply;
using Talk::HelloRequest;
using Talk::Greeter;

class TalkingService final : public  Greeter::Service
{
	Status SayHello
    (ServerContext* context, const HelloRequest* cText, HelloReply* sText)
    override
	{
		std::cout &lt;&lt; "Hello " &lt;&lt; cText->name()&lt;&lt;std::endl;
		std::cout &lt;&lt; "Your time is: " &lt;&lt; cText->date()&lt;&lt;std::endl;
		sText->set_message("Hello " + cText->name());
		return Status::OK;
	}
};

void RunServer()
{
	std::cout &lt;&lt; "Server stated listening on port 500521." &lt;&lt; std::endl;
	std::string ServerAddr("0.0.0.0:50051");
	TalkingService msgTalkService;
	ServerBuilder builder;
	builder.AddListeningPort(ServerAddr, 
            grpc::InsecureServerCredentials());
	builder.RegisterService(&amp;msgTalkService);
	std::unique_ptr&lt;Server&gt; server(builder.BuildAndStart());
	server->Wait();
}
int main()
{
	RunServer();
	return 0;
}
            </code></pre>
            <div class="code_footer">                
            <b>Server.cpp</b>
            </div>
        </div>
            At this point it would be cool if you hit <b>Rebuild Solution</b> and probably get an error. If no error occured then you can go ahead but <b>if there was an error while building Server</b> you should read this quick message: <ul><li>if the error is from <b>port_platform.h</b> and it talks about <b>_WIN32_WINNT</b> being less than <b>0x600</b> then you just have to click twice no that error so that <b>port_platform.h</b> opens. Now paste this line in there: <b>#define _WIN32_WINNT 0x600</b> and try <b>rebuilding</b> again</li>
            <li>if rebuild went succesfully then great! But if not yuo have to fix that yourself, find in the internet OR report as an issue in the main GIT repo of this project. You can also message me (contact provided at the end if this page).</li></ul>
            <br/>Okay, time for some <b>Client</b> code!!<br/>Add <b>Client.cpp</b> to your Client project and let's go!<br/>I hope your client is configured as we have shown earlier. Code for client side look like this:
            <div>
            <pre class="code_wrapper"><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;grpcpp/grpcpp.h&gt;
#include &lt;Talk.grpc.pb.h&gt;
#include &lt;ctime>&gt;

using grpc::Status;
using grpc::Channel;
using grpc::ClientContext;
using grpc::ClientWriter;
using grpc::ServerContext;
using Talk::HelloReply;
using Talk::HelloRequest;
using Talk::Greeter;

class GreeterClient
{
public:
	GreeterClient(std::shared_ptr&lt;Channel&gt; channel) :
    serverStub(Greeter::NewStub(channel)) {}
	void SendMesg(std::string name, std::string time)
	{
		HelloRequest request;
		HelloReply reply;
		Status status;
		ClientContext context;
		request.set_date(time);
		request.set_name(name);
		status = serverStub->SayHello(&amp;context, request, &amp;reply);
		if (status.ok())
		{
			std::cout &lt;&lt; reply.message() &lt;&lt; std::endl;
		}
		else
		{
			std::cout &lt;&lt; "\r";
			std::cout &lt;&lt; status.error_code();
                        std::cout &lt;&lt; ": " &lt;&lt; status.error_message() &lt;&lt; std::endl;
		}
	}
private:
	std::unique_ptr&lt;Greeter::Stub&gt; serverStub;
};

int main()
{
	grpc_init();
	std::string name;
	std::string time;
	std::time_t t;	
	std::tm* now = new std::tm;	
	std::cout &lt;&lt; "Enter your name: ";
	std::cin >> name;
	t = std::time(0);
	localtime_s(now, &amp;t);
	time = std::to_string(now->tm_hour) +
    ":" + std::to_string(now->tm_min) +
    ":" + std::to_string(now->tm_sec);
	GreeterClient client(grpc::CreateChannel(
            "127.0.0.1:50051", 
            grpc::InsecureChannelCredentials()));
	client.SendMesg(name, time);
	system("pause");
	grpc_shutdown();
	return 0;
}
            </code></pre>
            <div class="code_footer">                
            <b>Client.cpp</b>
            </div>
        </div>
            I haven't explained any code here or in the server description because well, you program in C++, you can figure it out! But I want to <b>point out</b> one important thing: <b>grpc_init()</b> and <b>grpc_shutdown()</b> functions. They ahve to be called inside to set everything up on the gRPC side. Try removing one of them and running client again.<br/>
            And that's all! One more thing: Both <b>.exe</b> files landed in my <b>TalkingServer\Release</b> directory but I guess that was expected. If you went to Client directory to find .exe you should se if it is maybe stored in the Server directory. End result:<br/><img src="./images/cpp_end_result.JPG"/><br/>If you want to see another example of a bigger C++ gRPC project check out my <a href="https://github.com/TheFunnySunny/gRPC-console-messanger-c-">console messanger.</a>
        </div>
        <div class="go general_div" id="go_ref">
        <div class="header">
            <h1>Creating Go microservice</h1>
        </div>
        Okay, to start with <b>Go</b> we will have to configure few things. First and foremost you need to have <b>Go</b> configured and it ahs to be usable from PS or cmd.<br/>
            To get all files needed to compile your proto and stuff like that you can fallow <a href="https://grpc.io/docs/quickstart/go.html">this tutorial</a> on how to download everything using Go. I will just drop all the commands in here, just in case: <ol><li><b>go version</b> which should return something higher or equal to 1.6</li>
            <li><b>go get -u google.golang.org/grpc</b> to install grpc for Go</li>
            <li><b>go get -u github.com/golang/protobuf/protoc-gen-go</b> to download Go plugin for protoc</li>
            <li>after that you have to add <b>$GOPATH/bin</b> to your <b>PATH</b>. If you do not know how to do so <a href="#howto_PATH_var">go here for a quick guide</a> or try this command <b>export PATH=$PATH:$GOPATH/bin</b>. This will ensure you have your protoc gen visible for your <b>protoc compiler</b> but it is not necessary. I will show you how to generate your files without adding this to your <b>PATH</b>.</li>
            </ol>
            Nice. We got that settled. We can jump into compiling our proto file. 
            <ol><li>I have created myself a folder with my Go project and 2 subfolders: 'client' and 'server'. I have also made one folder inside my <b>GOPATH</b> - <b>C:\Users\pshad\go\src\</b> and named it <b>TalkProject</b> so it I have that path in mind right now: <b>C:\Users\pshad\go\src\TalkProject</b>. Now I paste our <b>Talk.proto</b> into <b>TalkProject</b> folder and <b>navigate my PS</b> to this directory</li>
            <li>now in PS use this command: <b>protoc Talk.proto --go_out=plugins=grpc:.</b> or if you haven't put $GOPATH\bin into you PATH you ahve to specify where <b>go plugin</b> is.<br/>
                Your command should therefore look something like that: <b>protoc Talk.proto --plugin=protoc-gen-go=C:\Users\pshad\go\bin\protoc-gen-go.exe --go_out=plugins=grpc:.</b> which is a little longer but acutally I added one bonus thing which is <b>--plugin=protoc-gen-grpc='my path to that plugin'</b>. So if you had problems with your <b>GOPATH</b> use this one to generate your files</li>
            </ol>
          Okay, that's it for our proto stuff, we can now create our <b>Go gRPC server</b>. Navigate to your <b>server</b> subfolder in your project directory, for me it is <b>'D:\SOurceTree_Repo\gRPC-microservices-windows\Go\server'</b> and create a new file called <b>server.go</b>. Open it up and start writing your code! Your simplest server code sohuld look like that at the end:<br/>
            <div>
            <pre class="code_wrapper"><code>package main

import (
	pb "TalkProject"
	"context"
	"log"
	"net"

	"google.golang.org/grpc"
)

type server struct{}

func (s *server) SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloReply, error) {
	log.Printf("Received message from %v at %v", in.Name, in.Date)
	repl := "Hello " + in.Name
	return &amp;pb.HelloReply{Message: repl}, nil
}

func main() {
	lis, err := net.Listen("tcp", "0.0.0.0:50051")
	if err != nil {
		log.Fatalf("failed to listen: %v", err)
	}
	s := grpc.NewServer()
	log.Printf("Server listening on: " + lis.Addr().String())
	pb.RegisterGreeterServer(s, &amp;server{})
	if err := s.Serve(lis); err != nil {
		log.Fatalf("failed to serve: %v", err)
	}
}

            </code></pre>
            <div class="code_footer">                
            <b>server.go</b>
            </div>
            </div>
            Nice! What's letf you askin'? Client side!<br/>Navigate to your <b>client</b> subfolder and create <b>client.go</b> file. Open it up and start typing..: 
            <div>
            <pre class="code_wrapper"><code>package main

import (
	pb "TalkProject"
	"bufio"
	"context"
	"fmt"
	"log"
	"os"
	"time"

	"google.golang.org/grpc"
)

const (
	address = "127.0.0.1:50051"
)

func main() {
	// Set up a connection to the server.
	conn, err := grpc.Dial(address, grpc.WithInsecure())
	if err != nil {
		log.Fatalf("did not connect: %v", err)
	}
	defer conn.Close()
	c := pb.NewGreeterClient(conn)

	reader := bufio.NewReader(os.Stdin)
	fmt.Print("Enter your name: ")
	name, _ := reader.ReadString('\n')
	ctx, cancel := context.WithTimeout(context.Background(), time.Second)
	defer cancel()
	r, err := c.SayHello(ctx, &amp;pb.HelloRequest{Name: name, Date: time.Now().String()})
	if err != nil {
		log.Fatalf("could not send: %v", err)
	}
	log.Printf("Response: %s", r.Message)
}

            </code></pre>
            <div class="code_footer">                
            <b>client.go</b>
            </div>
        </div>
            One last thing to do if you want to distribute them as .exe files. Right now in your PS you can run <ul><li><b>go run server.go</b></li><li><b>go run client.go</b></li></ul>
            in the dorectory of server and client but this will only compile them once and will have to do so every time you do <b>go run</b>. A better approach will be to compile them to <b>.exe</b> files to save ourselves some time. To do so in the appropriate folder use these commands: <ul>
            <li><b>go build -o client.exe</b> in <b>client directory</b></li>
            <li><b>go build -o server.exe</b> in <b>server directory</b></li>
            </ul>
            And your exe files should be created in the directory of your <b>client</b> and <b>server</b>!<br/>
            If you want to download full project <a href="https://github.com/TheFunnySunny/gRPC-microservices-windows">go to my github repo of Go gRPC.</a><br/>
            If you have any suggestions or questions post them in the issues in git repo. Feedback is vastly appreacited!
    </div>
        <div class="entry general_div" id="rust_ref">
        <div class="header">
            <h1>Creating RUST microservice</h1>
        </div>
        <div class="general_text">
        Building in process...
        </div>
    </div>
    </div>
</body>
</html>